/*
,zzszo1S3f3S33C333IuuG,,z,,,,,,zzzzzzz,z,,,zzz,zzz,zzsz,,,,,zzzzzz,zzz,zzz,zzzzzzz,zg8Z3C33SJSLLCILI
zoxi1x33fV00X0U8E66fJV8oz,,,,,,zczzzzzzzz,z,,,zzzzzzcsszzzzzzzzzzzzzzzzzzzzzzzzzzzyfTou30d6Ad6d5VfAS
z1tizJ3TIf3ZSf3fSV33y1JGJgz;.,,zz,;,,z,,,z,,,,,z,z,zzzzzzzzzzzzzzzcz,zzz,z,zzzzzzioos7uTZVSf33IIJ3JC
zguiitu355bVUA6VVZ5f37o7IS31s,,,z:,,z,::,;,;;:,,::,,,,,,,,z,zzzzi7yiszzzzzzzzziczzgyCSZS5fZTf33uuu3J
z133icouISI33Zfb5GSb565T30D@@UU#dAD@#E5Iotziuuzzzz,  :,zigzz,szzzyzzsiziotctzz,zzIIZ6ASVG6V0AV33CI3S
,z13AuzzxJI3fG5f6V6Z0XQ##Q$$NNN@NNNNNMMNNNMMM@@NNNMJS0NQQ0x,zoz,zz,,,;zzzzzzz,zu3SG5bbbA0GVf6GV33IZS
zzzgIVL7tuJA0UXEUDXEEDEREU0XGDAV#RD80$NMMMMMNMMNNMMMMMNNAz:.zz,zx: .;,,, ;,,;zcxu3SVfVGVGAff3TS53VVf
czcxST8ED8X0EUDUDXDXEE6T65fV5D#U@$NNNNMNMNNNMMMNMNNNMNNNMQz z7zzz .;,;:;zz,,,zov1yS3fIfSVZVf5SS3ZVXf
,zu36STSddATXUE06G5VbGyL0D@$N@N@NNNNNNNNNNNNNNNNNNNNMNNMMM8bR33zcg,,,;, :,zzsssc7i1uSTVTfISS3uV000U
:zZS3fd8ZLb8ASVG6fSuS3RE$#NNN@@$N@NNNNNNNNNNMNMNNNNNNNMNMNMMM$6V#6Jgz,s,::;:,,zztoovuyy1CIf3Sf000ARD
,z3X3I1C6dG0d53ZVVV88R@NNMMMN@$N@NNNNNNMNNNNNNNMMMNMNMMNNNNN$N@$RQ##Zfyzzz,,;,,,,iy3LLxI3T3fSVZf5EUs
,;IRE5530X8V6ZZI6EDEU3fSTA#$MNN@NNNNNNNNNNNNNNMNMMMNMNNNNNNNN@N@NNN@Qfuizzz,,:;.;,zsLJZTGGVfI3TfU#L,
,SRN@$$QU033I3uVJzz,,;,,,zzzt6$N@N$@$@$@NNNMNMNNNMNMNN@N@NNNNNNMMMMMMN$#0uzzzz,,,,,zztuLJTfVTV55LZCz
ENN$NRQRQEEd0f1,,zz:. .   ..,,zDN$@RQ#$$NNMNNNNNMNN@@$RDR$NNMNN#f7z,zzzzyuCzzzz,z,,,zzitJuI3680ZfE8c
@N#RD##@$NNN@A.,Lc      .v.  ,.,RN$$RQQ@NNNNNNNNNNN$Q$E##NMNJz   .   .   .,zzz,,,,,zzziuL33U@$X#$#vz
RQ#EQ#Q#$@MNMI vJ   Zz    ..zv, $N@QQR$Q$@NNNNNNN$$##DRQNN5..   . . ..,zz  ,zz,,,.;;,zst3VD@NQ$U5zzz
D$XEERQ@$N@NMM0Jz:     .  .z3y zQN@@QRR$R$Q$QQQ@QQRRD$R$@b:,x,     zz.. zA,;zz,. .::.,,,,,cTVR0z,,,,
DRDUDDQQ@@NNMMMMN#0xszzz7y33i,zf#Q$QQ#QR$RQR$Q$RQ#RDRRN#Zz,of,yt  .  .,  E0 ,ugz,..   ..;.: ,itz177x
URU#E#D$QN$N@NNMMMMMMMMMMNN@D#MNQ$#RR$Q$#RE#E#RQRQ#$D#REVJ. c7z; .   .  ,u:.s0Vuzizz,. . :;: :z3$N@@
EDEEE0E#RD##$Q$$NNMNMMMNNNN@NNN$$QQEDEDUX80b08EXD#$R#UE##$TzV66bVcz,,,z1usuQNX3czzozzzz.  ;;,;:,uD@E
0#XUUE0XA0X#DQRQRQRQRQR$Q@$NNN@@QR88bXd0V0dX68bX68dE#QDQQ@NNNNNMMMMMMMMMMMMM@Ufuizzz,,zz,: :,,,;;oDQ
0U856ZVfb8D#Q#DEDE#D##RD#DRR#Gux335VDEU6U0EXEDREDbVZUE$#QQ@$N@NNMMMMMMMMMMMMMMM@#VTxggVVt;:..:,,;,VR
bEGVZV5UX#EDEDEEU##R##D##R#QEZyvzi,,;i066dG060VSu3LucszZRQ#Q#QR$Q$Q@$@@@$$QNNNNNNN$@$@N@Vz . .,,,zx$
5bA56AddU8Xb80X6U0U0EUD#QQQQN@N$#SCczzZZ33L3A3,  .,zi138#U#R#DRE#E#D##R#R#RUUUQ$N$$$N$@NN8i,,::,z,s0
Z0fZT5fZTbGbVVZdA8d06X8UXEUDERR@$$D8IuxIygxSIIyCS8E@NNNNQ$QQRQ#DU#E#DRD#D#EDdT3XD$Q$#$R@@NRE3z,;:zL$
66VTSISLSL3IT3f3fSV50A0VA5dA6AdGAb8653Lx1iuJIIV0DR@$$RQRQ#R#QRQEU0DUEXUUDD#DR6utJS0EQ#Q#$$@RRX3zzuR@
SdSSLIJICIuuyLxtzcc7uCJ3T53T3fSfSZSSSGJ1zg3VSZfG5dV8d08U080U0U80A008A0dDEE00U#VIuu30U##QR$QRUD0XX#NN
33SC333C3uuguxozz,,,,,,,zcizisvvostcooyzzzxCIL3J33f5VZ55X08f5TZfZSVS3L5ffVAZ5fdbfCZV8U#R$$@$NN@$N@N@
LfC3L3ISCICLxuyuiisvczzszzzz,z,z,zzz,zzz,,zzzzzzzizsziiyvtoyt7i77uyIJ3J3xu3VfZ3Zb0ZddXDR$N$@$NNN@NNN
3SSISIS33L3JLuIC3uILJyJuJuuxuxu1g1u71tx1tcvzzsszzzzzzzzzzzzzzzzzz,oyJ1yu3JuuTffIVU#E#ERDQR$RQ$N@@$NN
LVIf3T3S3TIIL3u3CIC3ITIS3f3SIS3fTfILuuuLJIxu1u11ty1giy7xyy77iocvzszov7tgyCyLfAGfSVVXER#RDQQQQN@N@NNN
TfT3fSZSfSTISLILII3L333CILIIIJI33C3IfSSJI3SLICf33LTLIxLJ3L3uug1oytytuguxJJ3SAfZ3T333A8RDRR$$$$N@N@NN
3V3fSZSVSfTZSTI3I3CIJ3JIL3JJJLJILLC3IIJ3I3I3J333JS3f3uu3JJuLyy1yyJguuCJICTSGS5TZ3Sfb50XD#QR$$$Q@@NNN
T5SSZSVG5fAfAffSZ3S33uLuCJ3JLLLu3uLJIuJuIu3LSI33IL3uu7yyx1ygxyuyuuJuIJLI3C3IS3f333A56b8X#ERD$Q@NNNMN
JfITSZSfSGZ5fAZVfGTfI3JIJIC3J3JCuCuCxuxJxJxJuLLL1gooigoy7x1xguyCuIuuyuuIIS3S3ZfVSVd88DUDE#D##@$NNNNN
I3LL3IS3SSfSZS5S5fGTfTf3SL3C3CIuJuIuuyu1yyuyuyy7yo1voitoy7u1y7y7xtgoyuS3VfZ3G50A0dUXDDDE##$$NNNNNNNN
SZuJu3C33SIT3SST3ffGS5fGfZSSL3I3C3JIuJyuyugyt7o1vtcvsoc7o11y7uyuxxxIITT5ZbVdbX8X8UUEE##QD##@NNNNNNNN
66fCCu3uCJLI3JII33fSfSGffST3fI3C33TCIuCxxyuyytyog1gt71yyJuuuLJ3IfT5Gd60Ad0UXEU#E#DR#$Q$RQQNNNNNNNNMN
VUVV3ICIuLu3JLJIC3I3L3I3C3L3I3I3CSIT33J3ISI3L3JIL3I3ISL3L3LTS5fAVbVA68AdV6dE0U8#E#EEEQ#RQ@NNNNNNNNMN
fXXXE08VAS5fZffSZTGSS3fSf3fT5fVG65VZAVdAAV0VbZVZVZAZ6V6A0bd5VV6d88UX##RE#EQQ@RQQ$$@Q@$NNMMMMMMMMMMMM
*/
#include <bits/stdc++.h>
using namespace std;
#define IO_FAST \
    cin.tie(0); \
    ios::sync_with_stdio(0)
#define ll long long
#define LL long long
#define ld long double
#define EPS 1e-3
#define cl(x) ((x << 1))
#define cr(x) ((x << 1) + 1)
#define FZ(x) memset(x, -1, sizeof(x))
#define lowbit(x) (x & -x)
#define INF 0x3f3f3f3f
#define INFLL 0x3f3f3f3f3f3f3f3f
#define endl '\n'
#define pii pair<int, int>
#define pll pair<ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define MP make_pair
#define PB push_back
#define pi acos(-1)
#define ALL(a) a.begin(), a.end()
#define SZ(x) ((int)x.size())
#define asort(a) sort(a.begin(), a.end())                 //升冪排序
#define dsort(a) sort(a.begin(), a.end(), greater<int>()) //降冪排序
#define dsortll(a) sort(a.begin(), a.end(), greater<ll>())
const int mod = 1e9 + 9;
inline int read()
{ //快读
    char ch = getchar();
    int x = 0, f = 1;
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
        x = x * 10 + (ch ^ 48), ch = getchar();
    return x * f;
}

int n, m, z, t, u, h, v, x, y, q, s;
int tmp[200005] = {0};
struct pt
{
    double x, y;
};
vector<pt> rec;
bool cmpX(pt a, pt b)
{
    if (a.x == b.x)
        return a.y < b.y;
    return a.x < b.x;
}
bool cmpY(int a, int b)
{
    if (rec[a].y == rec[b].y)
        return rec[a].x < rec[b].x;
    return rec[a].y < rec[b].y;
}
double dis(pt a, pt b)
{
    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}
double divide(int l, int r)
{
    if (l == r)//只有一點
        return INF;
    if (l + 1 == r)//只有兩點
        return dis(rec[l], rec[r]);
    int mid = (l + r) >> 1;
    double d = min(divide(l, mid), divide(mid + 1, r));
    int c = 0;
    for (int i = l; i <= r; i++)//找出離中線距離<=d的點
    {
        if (abs(rec[mid].x - rec[i].x) <= d)
            tmp[c++] = i;
    }
    sort(tmp, tmp + c, cmpY);//對y軸做排序 其只需要考慮y座標大於當前計算座標的y座標即可
    for (int i = 0; i < c; i++)
    {
        for (int j = i + 1; j < c && rec[tmp[j]].y - rec[tmp[i]].y < d; j++)
        {
            double ttmp = dis(rec[tmp[i]], rec[tmp[j]]);
            d = min(d, ttmp);
        }
    }
    return d;
}
void solve()
{
    cin >> n;
    rec.resize(n);
    for (int i = 0; i < n; i++)
        cin >> rec[i].x >> rec[i].y;
    sort(ALL(rec), cmpX);
    cout << fixed << setprecision(4) << divide(0, n - 1) << endl;
    return;
}
int main()
{

    // freopen("input.txt","r",stdin);    // 讀 file.in 檔
    // freopen("output.txt","w",stdout);  // 寫入 file.out 檔
    // IO_FAST;
    solve();
    return 0;
}
/*最近點對 心得:

    複雜度(nlong)
    考慮分治法:
    先對點做x軸排序，再將其分割成左右平面，分別找出左右平面最短距離

    但之後需要考慮以該中線為基準且x,y軸方向距離<d的座標 ( 也就是中線左右各一點形成的最短距離)
    考慮最後的中線，以y軸分割成兩邊<=d的的範圍可能有多少座標?

    先考慮中線右邊，對其做日字範圍
    Y
    |--------|
    |        |
    |        |
0   |--------|X
    |        |
    |________|
    ~   d    ~
    
    在這底為d 高為2d的矩形中，最多只會有6個點 ，左右都考慮最多12個
*/
